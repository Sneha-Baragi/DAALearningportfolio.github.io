<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Learning Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        /* Custom Button Styling */
        button {
            font-size: 1.1rem;
            font-weight: bold;
            color: #fff;
            background-color: #ff9800;
            border: none;
            padding: 12px 24px;
            margin: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        button:hover {
            background-color: #e68900;
            transform: scale(1.05);
        }

        button:active {
            background-color: #d97700;
            transform: scale(1);
        }

        /* Reflections Content */
        #reflections {
            background-color: #f9f9f9;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        #reflections h2 {
            color: #4CAF50;
        }

        #reflections p {
            text-align: left;
            line-height: 1.6;
        }

        .code {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 1.1rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <header>
        <h1>Hello, I'm Sneha Sanjeevkumar Baragi üëã</h1>
        <p>I am passionate about technology and problem-solving. Here's a glimpse of my work:</p>
    </header>

    <section>
        <h2>üõ†Ô∏è Projects</h2>
        <ul>
            <li><strong>Project 1</strong>: City Design - A Layout of Smart City</li>
            <li><strong>Project 2</strong>: Implementing Real-World Traffic Monitoring and Management</li>
        </ul>

        <h2>üöÄ Skills</h2>
        <ul>
            <li>C++, Python, C Programming</li>
            <li>Data Structures and Algorithms</li>
        </ul>

        <h2>üåê Find Me Online</h2>
        <ul>
            <li><a href="https://github.com/your-github-username" target="_blank">GitHub</a></li>
            <li><a href="https://www.linkedin.com/in/sneha-baragi-8212172aa" target="_blank">LinkedIn</a></li>
        </ul>

        <h2>Portfolio Topic</h2>
        <dl>
            <dt>Course Name</dt>
            <dd>Design and Analysis of Algorithms</dd>

            <dt>Course Code</dt>
            <dd>24ECAC203</dd>

            <dt>Name</dt>
            <dd>Sneha Sanjeevkumar Baragi</dd>

            <dt>SRN</dt>
            <dd>01FE23BCI054</dd>

            <dt>Course Instructor</dt>
            <dd>K M M Rajashekharaiah</dd>

            <dt>University</dt>
            <dd>KLE Technological University Hubballi</dd>

            <dt>Portfolio Topic/Domain</dt>
            <dd>Learning Portfolio</dd>
        </dl>

        <blockquote>‚ÄúHard work beats talent when talent doesn't work hard.‚Äù ‚Äì Tim Notke</blockquote>

        <div>
            <button onclick="showReflections('lab')">Lab Reflections</button>
            <button onclick="showReflections('theory')">Theory Reflections</button>
        </div>

        <div id="reflections" style="display:none; margin-top: 20px;">
            <h2 id="reflection-title"></h2>
            <p id="reflection-content"></p>
        </div>
    </section>

    <script>
        function showReflections(type) {
            const title = document.getElementById('reflection-title');
            const content = document.getElementById('reflection-content');
            const reflections = document.getElementById('reflections');

            if (type === 'lab') {
                title.innerText = 'Lab Reflections';
                content.innerHTML = `
                    <h3>Key Concepts / Things Learned in This Course</h3>
                    <h4>Time Complexity Analysis</h4>
                    
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Concepts and Examples</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3, h4 {
            color: #444;
        }
        .container {
            width: 90%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
        }
        pre {
            background: #e8e8e8;
            padding: 15px;
            border-left: 4px solid #6c757d;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DAA Concepts and Examples</h1>

        <h2>Length of String</h2>
        <pre>
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

// Function to calculate the length of the string recursively
int getlength(char *str, int length) {
    if(*str != '\0'){
        length++;
        str++;
        return getlength(str, length);
    }
    return length;
}

int main() {
    char str[100];
    int length = 0;
    printf("Enter a string: ");
    scanf("%s", str);

    // Start measuring time
    clock_t start = clock();

    // Calculate the length of the string
    length = getlength(str, length);

    // Stop measuring time
    clock_t end = clock();
    double elapsed = ((double)(end - start)) / CLOCKS_PER_SEC;

    // Print the result
    printf("The length is %d\n", length);
    printf("Time taken for execution: %f seconds\n", elapsed);

    return 0;
}
        </pre>

        <table>
            <thead>
                <tr>
                    <th>Length (n)</th>
                    <th>Library</th>
                    <th>Recursion</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>100</td><td>3</td><td>3</td></tr>
                <tr><td>500</td><td>3</td><td>3</td></tr>
                <tr><td>1000</td><td>4</td><td>4</td></tr>
                <tr><td>5000</td><td>4</td><td>4</td></tr>
                <tr><td>10000</td><td>5</td><td>5</td></tr>
                <tr><td>50000</td><td>5</td><td>5</td></tr>
            </tbody>
        </table>

        <h3>Challenges in Learning</h3>
        <ul>
            <li>Understanding time complexity of algorithms like Tower of Hanoi, linear and binary search, and string length calculations.</li>
            <li>Strong mathematical foundations and abstract nature of theoretical concepts.</li>
        </ul>

        <h3>Challenges in Correlating with Real-World Applications</h3>
        <ul>
            <li>Adapting algorithms to handle real-world data and constraints.</li>
            <li>Bridging the gap between abstract ideas and practical use.</li>
        </ul>

        <h3>Determining Efficient Approaches</h3>
        <ul>
            <li>Clearly define the problem and break it down into smaller parts.</li>
            <li>Research existing solutions and iteratively test and refine the approach.</li>
        </ul>

        <h2>Binary Search Tree</h2>
        <pre>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

struct tree {
    int data;
    struct tree* left;
    struct tree* right;
};

typedef struct tree TREE;

class Binarysearchtree {
public:
    TREE* insert_into_bst(TREE*, int);
    void inorder(TREE*);
    void preorder(TREE*);
    void postorder(TREE*);
    TREE* delete_from_bst(TREE*, int);
};

TREE* Binarysearchtree::insert_into_bst(TREE* root, int data) {
    TREE* newnode = (TREE*)malloc(sizeof(TREE));
    if (newnode == NULL) {
        cout &lt;&lt; "Memory allocation failed" &lt;&lt; endl;
        return root;
    }
    newnode->data = data;
    newnode->left = NULL;
    newnode->right = NULL;
    if (root == NULL) {
        root = newnode;
        cout &lt;&lt; "Root node inserted into tree" &lt;&lt; endl;
        return root;
    }
    TREE* curnode = root;
    TREE* parent = NULL;
    while (curnode != NULL) {
        parent = curnode;
        if (newnode->data < curnode->data) {
            curnode = curnode->left;
        } else {
            curnode = curnode->right;
        }
    }
    if (newnode->data < parent->data) {
        parent->left = newnode;
    } else {
        parent->right = newnode;
    }
    cout &lt;&lt; "Node inserted successfully into the tree" &lt;&lt; endl;
    return root;
}

// Inorder Traversal
void Binarysearchtree::inorder(TREE* root) {
    if (root != NULL) {
        inorder(root->left);
        cout &lt;&lt; root->data &lt;&lt; "\t";
        inorder(root->right);
    }
}

// Preorder Traversal
void Binarysearchtree::preorder(TREE* root) {
    if (root != NULL) {
        cout &lt;&lt; root->data &lt;&lt; "\t";
        preorder(root->left);
        preorder(root->right);
    }
}

// Postorder Traversal
void Binarysearchtree::postorder(TREE* root) {
    if (root != NULL) {
        postorder(root->left);
        postorder(root->right);
        cout &lt;&lt; root->data &lt;&lt; "\t";
    }
}

// Delete Node
TREE* Binarysearchtree::delete_from_bst(TREE* root, int data) {
    TREE* curnode = root;
    TREE* parent = NULL;
    TREE* successor = NULL;
    TREE* p = NULL;

    if (root == NULL) {
        cout &lt;&lt; "TREE is empty" &lt;&lt; endl;
        return root;
    }

    while (curnode != NULL && curnode->data != data) {
        parent = curnode;
        if (data < curnode->data) {
            curnode = curnode->left;
        } else {
            curnode = curnode->right;
        }
    }

    if (curnode == NULL) {
        cout &lt;&lt; "Item not found" &lt;&lt; endl;
        return root;
    }

    if (curnode->left == NULL) {
        p = curnode->right;
    } else if (curnode->right == NULL) {
        p = curnode->left;
    } else {
        successor = curnode->right;
        while (successor->left != NULL) {
            successor = successor->left;
        }
        successor->left = curnode->left;
        p = curnode->right;
    }
    if (parent == NULL) {
        free(curnode);
        return p;
    }

    if (curnode == parent->left) {
        parent->left = p;
    } else {
        parent->right = p;
    }
    free(curnode);
    return root;
}

int main() {
    Binarysearchtree bst;
    TREE* root = NULL;
    int choice = 0, data = 0;
    while (1) {
        cout &lt;&lt; "\n*MENU\n";
        cout &lt;&lt; "1-Insert into BST\n";
        cout &lt;&lt; "2-Inorder Traversal\n";
        cout &lt;&lt; "3-Preorder Traversal\n";
        cout &lt;&lt; "4-Postorder Traversal\n";
        cout &lt;&lt; "5-Delete from BST\n";
        cout &lt;&lt; "Any other option to exit\n";
        cout &lt;&lt; "*\n";

        cout &lt;&lt; "Enter your choice: ";
        cin &gt;&gt; choice;
        switch (choice) {
            case 1:
                cout &lt;&lt; "Enter the item to insert: ";
                cin &gt;&gt; data;
                root = bst.insert_into_bst(root, data);
                break;
            case 2:
                if (root == NULL) {
                    cout &lt;&lt; "Tree is empty\n";
                } else {
                    cout &lt;&lt; "Inorder traversal is..\n";
                    bst.inorder(root);
                }
                break;
            case 3:
                if (root == NULL) {
                    cout &lt;&lt; "Tree is empty\n";
                } else {
                    cout &lt;&lt; "Preorder traversal is..\n";
                    bst.preorder(root);
                }
                break;
            case 4:
                if (root == NULL) {
                    cout &lt;&lt; "Tree is empty\n";
                } else {
                    cout &lt;&lt; "Postorder traversal is..\n";
                    bst.postorder(root);
                }
                break;
            case 5:
                cout &lt;&lt; "Enter the item to be deleted: ";
                cin &gt;&gt; data;
                root = bst.delete_from_bst(root, data);
                break;
            default:
                cout &lt;&lt; "Exiting code:\n";
                exit(0);
        }
    }
    return 0;
}
        </pre>

        <h3>Challenges in Learning</h3>
        <ul>
            <li>Understanding hierarchical structure and recursive operations in binary search trees.</li>
            <li>Handling edge cases like duplicate keys or node deletions.</li>
        </ul>

        <h3>Challenges in Correlating with Real-World Applications</h3>
        <ul>
            <li>Identifying use cases and performance trade-offs in dynamic scenarios.</li>
            <li>Maintaining balanced structures for efficiency.</li>
        </ul>

        <h3>Determining Efficient Approaches</h3>
        <ul>
            <li>Analyze problem requirements and compare with alternatives like hash tables or balanced trees.</li>
            <li>Test with real-world data and evaluate complexity.</li>
        </ul>
    </div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Concepts and Examples</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3, h4 {
            color: #444;
        }
        .container {
            width: 90%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
        }
        pre {
            background: #e8e8e8;
            padding: 15px;
            border-left: 4px solid #6c757d;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DAA Concepts and Examples</h1>

        <h2>Depth-First Search (DFS) and Breadth-First Search (BFS)</h2>
        <h3>DFS Code</h3>
        <pre>
#include &lt;iostream&gt;
using namespace std;

int v = 5;
int m[10][10] = {{0,1,1,0,0}, {1,0,0,1,1},
        {1,0,0,0,1}, {0,1,0,0,0}, {0,1,1,0,0}};
int visited[10];

void dfs(int m[10][10], int v, int source) {
    visited[source] = 1;
    for (int i = 0; i < v; i++) {
        if (m[source][i] == 1 && visited[i] == 0) {
            cout &lt;&lt; i &lt;&lt; "\t";
            dfs(m, v, i);
        }
    }
}
int main() {
    int source;
    for (int i = 0; i < v; i++)
        visited[i] = 0;

    cout &lt;&lt; "Enter the source vertex: ";
    cin &gt;&gt; source;

    cout &lt;&lt; "The DFS Traversal is... \n";
    cout &lt;&lt; source &lt;&lt; "\t";
    dfs(m, v, source);

    return 0;
}
        </pre>

        <h3>BFS Code</h3>
        <pre>
#include &lt;iostream&gt;
using namespace std;

void bfs(int m[10][10], int v, int source) {
    int queue[20];
    int front = 0, rear = 0, u, i;
    int visited[10];

    for (i = 0; i < v; i++)
        visited[i] = 0;

    queue[rear] = source;
    visited[source] = 1;

    cout &lt;&lt; "The BFS Traversal is... \n";

    while (front <= rear) {
        u = queue[front];
        cout &lt;&lt; u &lt;&lt; "\t";
        front++;

        for (i = 0; i < v; i++) {
            if (m[u][i] == 1 && visited[i] == 0) {
                visited[i] = 1;
                rear++;
                queue[rear] = i;
            }
        }
    }
}

int main() {
    int v = 5;
    int m[10][10] = {{0,1,1,0,0}, {1,0,0,1,1},
        {1,0,0,0,1}, {0,1,0,0,0}, {0,1,1,0,0}};

    int source;
    cout &lt;&lt; "Enter the source vertex: ";
    cin &gt;&gt; source;

    bfs(m, v, source);

    return 0;
}
        </pre>

        <h3>Challenges in Learning DFS and BFS</h3>
        <ul>
            <li>Difficulty understanding traversal mechanisms and implementation details.</li>
            <li>Managing data structures like stacks (DFS) or queues (BFS).</li>
            <li>Handling edge cases like cycles and disconnected graphs.</li>
        </ul>

        <h3>Challenges in Correlating DFS and BFS with Real-World Applications</h3>
        <ul>
            <li>Mapping abstract nodes and edges to real-world entities like cities or networks.</li>
            <li>Choosing the appropriate graph representation for a given scenario.</li>
        </ul>

        <h2>Heap</h2>
        <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void Heapify(vector&lt;int&gt;& H, int i, int n) {
    int v;
    for (int i = n / 2; i >= 1; i--) {
        v = H[i];
        bool heap = false;

        while (!heap && 2 * i <= n) {
            int j = 2 * i;

            if (j < n && H[j] < H[j + 1]) {
                j = j + 1;
            }
            if (v >= H[j]) {
                heap = true;
            } else {
                H[i] = H[j];
                i = j;
            }
        }
        H[i] = v;
    }
}

int main() {
    vector&lt;int&gt; H = {7, 6, 17, 11, 64, 29, 6, 12, 2};
    for (int i = 1; i < H.size(); i++) {
        cout &lt;&lt; H[i] &lt;&lt; " ";
    }
    cout &lt;&lt; "\n";
    int n = H.size();
    int i;
    Heapify(H, i, n);
    cout &lt;&lt; "After heapification\n";
    for (int i = 1; i < H.size(); i++) {
        cout &lt;&lt; H[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    return 0;
}
        </pre>

        <h3>Challenges in Learning Heaps</h3>
        <ul>
            <li>Visualizing binary tree structure when implemented using arrays.</li>
            <li>Understanding and maintaining the "heap property" during insertion and deletion.</li>
        </ul>

        <h3>Challenges in Correlating Heaps with Real-World Applications</h3>
        <ul>
            <li>Identifying scenarios where heaps are optimal, such as priority queues or shortest path algorithms.</li>
            <li>Adapting heap implementations for large-scale systems or specific use cases.</li>
        </ul>

    </div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAA Concepts and Examples</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3, h4 {
            color: #444;
        }
        .container {
            width: 90%;
            margin: auto;
            overflow: hidden;
            padding: 20px;
        }
        pre {
            background: #e8e8e8;
            padding: 15px;
            border-left: 4px solid #6c757d;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f4f4f4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DAA Concepts and Examples</h1>

        <h2>Sorting Algorithms</h2>
        <h3>Bubble Sort</h3>
        <pre>
ALGORITHM BubbleSort(A[0..n-1])
// Sorts a given array using bubble sort
// Input: An array A[0..n-1] of orderable elements
// Output: Array A[0..n-1] sorted in ascending order
for i <- 0 to n - 2 do
    for j <- 0 to n - 2 - i do
        if A[j+1] < A[j]
            swap A[j] and A[j+1]
        </pre>

        <h3>Selection Sort</h3>
        <pre>
ALGORITHM SelectionSort(A[0..n-1])
// Sorts a given array using selection sort
// Input: An array A[0..n-1] of orderable elements
// Output: Array A[0..n-1] sorted in ascending order
for i <- 0 to n - 2 do
    min <- i
    for j <- i + 1 to n - 1 do
        if A[j] < A[min]
            min <- j
    swap A[i] and A[min]
        </pre>

        <h3>Insertion Sort</h3>
        <pre>
ALGORITHM InsertionSort(A[0..n-1])
// Sorts a given array using insertion sort
// Input: An array A[0..n-1] of orderable elements
// Output: Array A[0..n-1] sorted in ascending order
for i <- 1 to n - 1 do
    v <- A[i]
    j <- i - 1
    while j >= 0 and A[j] > v do
        A[j + 1] <- A[j]
        j <- j - 1
    A[j + 1] <- v
        </pre>

        <h3>Merge Sort</h3>
        <pre>
ALGORITHM MergeSort(A[0..n-1])
// Sorts a given A[0..n-1] by recursive mergesort
// Input: An array A[0..n-1] of orderable elements
// Output: Array A[0..n-1] sorted in nondecreasing order
if n > 1
    copy A[0...|n/2| - 1] to B[0...|n/2| - 1]
    copy A[|n/2|...n - 1] to C[0...|^n/2^| - 1]
    MergeSort(B[0...|n/2| - 1])
    MergeSort(C[0...|^n/2^| - 1])
    Merge(B, C, A)

ALGORITHM Merge(B[0...p-1], C[0...q-1], A[0...p+q-1])
// Merges two sorted arrays into one sorted array
// Input: Arrays B[0...p-1] and C[0...q-1] both sorted
// Output: Sorted array A[0...p+q-1] of the elements of B and C
i <- 0
j <- 0
k <- 0
while i < p and j < q do
    if B[i] <= C[j]
        A[k] <- B[i]
        i <- i + 1
    else
        A[k] <- C[j]
        j <- j + 1
    k <- k + 1
if i = p
    copy C[j...q - 1] to A[k...p + q - 1]
else
    copy B[i...p - 1] to A[k...p + q - 1]
        </pre>

        <h3>Quick Sort</h3>
        <pre>
ALGORITHM QuickSort(A[l...r])
// Sorts a subarray by quicksort
// Input: A subarray A[l...r] of A[0...n-1], defined by its left and right indices l and r
// Output: Subarray A[l...r] sorted in nondecreasing order
if l < r
    s <- Partition(A[l...r])
    QuickSort(A[l...s - 1])
    QuickSort(A[s + 1...r])

ALGORITHM Partition(A[l...r])
// Partitions a subarray by using its first element as a pivot
// Input: A subarray A[l...r] of A[0...n-1], defined by its left and right indices l and r (l < r)
// Output: Subarray A[l...r], with split position returned as this functions value
p <- A[l]
i <- l
j <- r + 1
repeat
    repeat i <- i + 1 until A[i] >= p
    repeat j <- j - 1 until A[j] <= p
    swap(A[i] and A[j])
until i >= j
swap (A[i], A[j])
swap (A[l], A[j])
return j
        </pre>

        <h3>Challenges in Learning Sorting Algorithms</h3>
        <ul>
            <li>Understanding the mechanisms of each algorithm.</li>
            <li>Determining time and space complexities for different scenarios.</li>
            <li>Implementing algorithms without errors and debugging code.</li>
        </ul>

        <h3>Challenges in Correlating with Real-World Applications</h3>
        <ul>
            <li>Handling messy and dynamic data sets effectively.</li>
            <li>Choosing appropriate algorithms based on specific requirements like stability and memory constraints.</li>
            <li>Integrating sorting efficiently into larger systems.</li>
        </ul>

        <h3>Design Techniques for Solving Complex Problems</h3>
        <ul>
            <li>Understand the problem thoroughly and break it into smaller parts.</li>
            <li>Analyze different approaches and their trade-offs in terms of time and space complexity.</li>
            <li>Choose the most suitable data structures and algorithms based on the constraints.</li>
            <li>Refine solutions iteratively through testing and optimization.</li>
        </ul>
    </div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Searching and Graph Algorithms</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        h1, h2 {
            color: #2C3E50;
        }
        h3 {
            color: #2980B9;
        }
        .content {
            margin-bottom: 20px;
        }
        .section {
            margin-top: 20px;
        }
        .algorithm {
            background-color: #ECF0F1;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        pre {
            background-color: #2C3E50;
            color: #ECF0F1;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>

    <h1>Pattern Searching and Graph Algorithms</h1>

    <!-- Pattern Searching Section -->
    <div class="section">
        <h2>Pattern Searching Algorithms</h2>

        <div class="content">
            <h3>1) What are the challenges in learning, understanding pattern searching methods like Rabin-Karp, Boyer-Moore, Brute Force string match, KMP?</h3>
            <p>Learning pattern searching algorithms like brute-force, KMP, Boyer-Moore, and Rabin-Karp presents several challenges. These include grasping the core logic of each algorithm, understanding the pre-processing steps involved in KMP and Boyer-Moore (like building prefix tables or bad character tables), and analyzing their time and space complexities. Implementing these algorithms correctly, especially handling edge cases and boundary conditions, can also be tricky. Furthermore, understanding the trade-offs between these algorithms and choosing the most suitable one for a given scenario requires careful consideration of factors like pattern and text length, and frequency of searches.</p>
            <p><strong>In short, the challenges are:</strong> understanding each algorithm's logic, mastering pre-processing steps (KMP, Boyer-Moore), analyzing performance, correct implementation (especially edge cases), and choosing the right algorithm for a specific use case.</p>
        </div>

        <div class="content">
            <h3>2) What are the challenges in correlating with real-world applications?</h3>
            <p>Applying pattern searching algorithms like Rabin-Karp, Boyer-Moore, brute-force, and KMP to real-world scenarios presents several challenges. These include handling the sheer scale and diverse nature of real-world data, which can be massive and contain various data types. Real-world patterns themselves can be complex, involving variable lengths, wildcards, approximate matches, or the need to search for multiple patterns simultaneously. Meeting stringent performance requirements, especially in applications like search engines or network security, is crucial. The preprocessing overhead of algorithms like KMP and Boyer-Moore, while improving search speed, must be considered, especially for infrequent searches. Memory usage can also be a constraint, particularly in resource-limited environments. Finally, integrating these algorithms with existing systems adds further complexity.</p>
            <p><strong>In short, the challenges are:</strong> large and diverse data, complex patterns, performance needs, preprocessing cost, memory limits, and system integration.</p>
        </div>

        <div class="content">
            <h3>3) How do you determine the most efficient approach/design techniques when solving complex problems?</h3>
            <p>To determine the most efficient approach for pattern searching with algorithms like Rabin-Karp, Boyer-Moore, brute-force, and KMP, consider these factors:</p>
            <ul>
                <li><strong>Pattern and text length:</strong> For short patterns and texts, brute-force might be sufficient. For longer ones, KMP, Boyer-Moore, or Rabin-Karp are more efficient.</li>
                <li><strong>Frequency of searches:</strong> If you're searching for the same pattern many times in different texts, the preprocessing overhead of KMP or Boyer-Moore becomes worthwhile.</li>
                <li><strong>Alphabet size:</strong> Boyer-Moore performs well with larger alphabets.</li>
                <li><strong>Expected matches:</strong> If matches are rare, Boyer-Moore tends to be very fast.</li>
                <li><strong>Memory constraints:</strong> Brute-force uses minimal memory, while KMP requires some extra space for the prefix table.</li>
            </ul>
        </div>
    </div>

    <!-- Graph Algorithms Section -->
    <div class="section">
        <h2>Graph Algorithms</h2>

        <div class="content">
            <h3>1) What are the challenges in learning, understanding graph algorithms concepts?</h3>
            <p>Understanding graph algorithms poses challenges due to their complex structures and the need for a strong foundation in discrete mathematics and graph theory. The diverse range of algorithms, like Dijkstra's, Bellman-Ford, and Kruskal's, each come with unique applications and complexities. Additionally, analyzing their efficiency and translating theoretical concepts into real-world applications can be daunting. Handling edge cases, such as disconnected graphs or negative weights, further adds to the complexity.</p>
        </div>

        <div class="content">
            <h3>2) What are the challenges in correlating with real-world applications?</h3>
            <p>Correlating graph algorithms with real-world applications can be challenging due to the complexity and variability of real-world data, which often differs significantly from the clean, structured data used in academic examples. Additionally, real-world scenarios may involve dynamic and large-scale graphs, requiring efficient handling of data updates and optimizations that aren't as straightforward. Moreover, practical constraints such as computational resources, time limits, and data quality can further complicate the direct application of theoretical algorithms, necessitating customized solutions and adaptations.</p>
        </div>

        <div class="content">
            <h3>3) How do you determine the most efficient approach/design techniques when solving complex problems?</h3>
            <p>Determining the most efficient approach for solving complex problems involving graph algorithms requires a systematic and iterative process. First, clearly define the problem and its constraints. Then, break the problem down into smaller, manageable parts and understand the underlying graph structure. Research and evaluate different algorithms, considering factors like time and space complexity, scalability, and ease of implementation. Use techniques such as divide and conquer, dynamic programming, or greedy algorithms based on the problem requirements. Prototype and test the chosen approach, analyze its performance, and iteratively refine it. Combining theoretical knowledge with practical experimentation ensures an efficient and effective solution.</p>
        </div>
    </div>

    <!-- Algorithm Sections -->
    <div class="section">
        <h2>Graph Algorithm Implementations</h2>
        
        <!-- Dijkstra's Algorithm -->
        <div class="algorithm">
            <h3>1.Dijkstra‚Äôs Algorithm</h3>
<pre>
Dijkstra(G, s) 
// Dijkstra‚Äôs algorithm for single source shortest path 
// Input: A weighted connected graph G(V, E) with non-negative weights and its vertex s 
// Output: the length dv of a shortest path from s to v and its penultimate vertex pv for 
// every vertex v in V 
Initialize(Q) // Initialize vertex priority queue to empty 
for every vertex v in V do 
    dv <- ‚àû 
    pv <- null 
    Insert(Q, v, dv) // Initialize vertex priority in priority queue 
ds <- 0 
Decrease(Q, s, ds) // Update priority of s with ds 
VT <- √ò 
for i <- 0 to |V| - 1 do 
    u* <- DeleteMin(Q) 
    VT = VT U {u*} 
    for every vertex u in V ‚Äì VT that is adjacent to u* do 
        if du* + w(u*, u) < du 
            du <- du* + w(u*, u) 
            pu <- u* 
            Decrease(Q, u, du)
            </pre>
        </div>

        <!-- Floyd's Algorithm -->
        <div class="algorithm">
            <h3>2.Floyd‚Äôs Algorithm</h3>
            <pre>
Floyd(W[1..n, 1..n]) 
// Implements Floyd‚Äôs algorithm for all pair shortest path problem 
// Input: The weight matrix W of the graph with no negative length cycle 
// Output: The distance matrix of the shortest path‚Äôs lengths 
D <- W 
for k <- 1 to n do 
    for i <- 1 to n do 
        for j <- 1 to n do 
            D[i, j] <- min {D[i, j], D[i, k] + D[k, j]} 
return D
            </pre>
        </div>

        <!-- Warshall‚Äôs Algorithm -->
        <h2>3. Warshall‚Äôs Algorithm</h2>
        <div class="algorithm">
            <h3>ALGORITHM Warshall (A[1..n,1..n])</h3>
            <p>// Implements Warshall‚Äôs algorithm for computing transitive closure</p>
            <p>// Input: The adjacency matrix A of a digraph with n vertices</p>
            <p>// Output: The transitive closure of the digraph</p>
            <pre>
R(0) <- A
for k <- 1 to n do
    for i <- 1 to n do
        for j <- 1 to n do
            R(k)[i, j] <- R(k-1)[i, j] or (R(k-1)[i, k] and R(k-1)[k, j])
return R(n)
            </pre>
        </div>

        <!-- Kruskal‚Äôs Algorithm -->
        <h2>4. Kruskal‚Äôs Algorithm</h2>
        <div class="algorithm">
            <h3>ALGORITHM Kruskal(G)</h3>
            <p>// Kruskal‚Äôs algorithm to construct a minimum spanning tree</p>
            <p>// Input: A weighted connected graph G(V, E)</p>
            <p>// Output: ET, the set of edges composing of MST of G</p>
            <pre>
sort E in nondecreasing order of the edge weights w(ei1) <= ‚Ä¶ <= w(ei|E|)
ET <- √ò
ecounter <- 0
k <- 0
while ecounter < |V| - 1 do
    k <- k + 1
    if ET U {eik} is acyclic
        ET <- ET U {eik}
        ecounter <- ecounter + 1
return ET
            </pre>
        </div>

        <!-- Prim‚Äôs Algorithm -->
        <h2>5. Prim‚Äôs Algorithm</h2>
        <div class="algorithm">
            <h3>ALGORITHM Prim(G)</h3>
            <p>// Prim‚Äôs algorithm to construct a minimum spanning tree</p>
            <p>// Input: A weighted connected graph G(V, E)</p>
            <p>// Output: ET, the set of edges composing of MST of G</p>
            <pre>
VT <- {v0}
ET <- √ò
for i <- 1 to |V| - 1 do
    find a minimum weight edge e* = (v*, u*) along all the edges (v, u) such that
        v is in VT and u is in V - VT
    VT <- VT U {u*}
    ET <- ET U {e*}
return ET
            </pre>
        </div>

        <!-- Bellman-Ford Algorithm -->
        <h2>6. Bellman-Ford Algorithm</h2>
        <div class="algorithm">
            <h3>Bellman-Ford Algorithm</h3>
            <pre>
d[s] ‚Üê 0
for each v ‚àà V ‚àí {s}
    do d[v] ‚Üê ‚àû  // initialization

for i ‚Üê 1 to |V| ‚àí 1
    do for each edge (u, v) ‚àà E
        do if d[v] > d[u] + w(u, v)
            then d[v] ‚Üê d[u] + w(u, v)  // relaxation step

for each edge (u, v) ‚àà E
    do if d[v] > d[u] + w(u, v)
        then report that a negative-weight cycle exists

At the end, d[v] = Œ¥(s, v), if no negative-weight cycles.
            </pre>
        </div>
    </section>

    <section class="challenge-section">
        <h2>Challenges in Learning, Understanding Graph Algorithms</h2>
        <p>Understanding graph algorithms poses challenges due to their complex structures and the need for a strong foundation in discrete mathematics and graph theory. The diverse range of algorithms, like Dijkstra's, Bellman-Ford, and Kruskal's, each come with unique applications and complexities. Additionally, analyzing their efficiency and translating theoretical concepts into real-world applications can be daunting. Handling edge cases, such as disconnected graphs or negative weights, further adds to the complexity.</p>
    </section>

    <section class="challenge-section">
        <h2>Challenges in Correlating with Real-World Applications</h2>
        <p>Correlating graph algorithms with real-world applications can be challenging due to the complexity and variability of real-world data, which often differs significantly from the clean, structured data used in academic examples. Additionally, real-world scenarios may involve dynamic and large-scale graphs, requiring efficient handling of data updates and optimizations that aren't as straightforward. Moreover, practical constraints such as computational resources, time limits, and data quality can further complicate the direct application of theoretical algorithms, necessitating customized solutions and adaptations.</p>
    </section>

    <section class="challenge-section">
        <h2>Determining the Most Efficient Approach/Design Techniques</h2>
        <p>Determining the most efficient approach for solving complex problems involving graph algorithms requires a systematic and iterative process. First, clearly define the problem and its constraints. Then, break the problem down into smaller, manageable parts and understand the underlying graph structure. Research and evaluate different algorithms, considering factors like time and space complexity, scalability, and ease of implementation. Use techniques such as divide and conquer, dynamic programming, or greedy algorithms based on the problem requirements. Prototype and test the chosen approach, analyze its performance, and iteratively refine it. Combining theoretical knowledge with practical experimentation ensures an efficient and effective solution.</p>
    </section>
        
    </div>

</body>
</html>

                  
            } else if (type === 'theory') {
                title.innerText = 'Theory Reflections';
                content.innerHTML = `
                    <h3>Course Overview</h3>
                    <p>This course dives deeply into the world of data structures and algorithms, emphasizing their creation, evaluation, and real-world applications in computational and engineering tasks. It integrates principles of mathematics, engineering, and advanced computer science techniques to equip students with the skills needed to analyze and solve a variety of computational problems.</p>

                    <h3>What is the Course About?</h3>
                    <p>The curriculum focuses on understanding the fundamental philosophies behind designing efficient algorithms and data structures. Topics include performance analysis methods, computational complexity, and strategies such as recursion, iteration, and backtracking. The course covers a wide array of data structures such as trees, graphs, heaps, and tries, as well as advanced algorithms for sorting, searching, shortest paths, and more.</p>

                    <h3>What Data Structures and Algorithms Did You Study?</h3>
                    <ul>
                        <li>Linear Data Structures: Arrays, linked lists, stacks, and queues.</li>
                        <li>Tree Structures: Binary search trees, AVL trees, red-black trees, heaps, and tries.</li>
                        <li>Graph Representations: Adjacency lists and matrices, along with traversal methods like DFS and BFS.</li>
                        <li>Specialized Structures: Segment trees, Fenwick trees, sparse tables, and skip lists.</li>
                    </ul>

                    <h3>How Does the Course Connect to Real-World Applications?</h3>
                    <ul>
                        <li>Web Applications: Database optimization through efficient searching and sorting.</li>
                        <li>Game Development: Managing dynamic events with tree-based structures.</li>
                        <li>Networking: Graph-based algorithms in routing protocols.</li>
                        <li>Data Analytics: Efficient range queries using segment or Fenwick trees.</li>
                        <li>Cybersecurity: Pattern searching in intrusion detection systems.</li>
                        <li>Machine Learning: Priority-based tasks using heaps.</li>
                    </ul>
                `;
            }

            reflections.style.display = 'block';
        }
    </script>
</body>
</html>
